import{_ as i,V as r,W as l,$ as t,a1 as o,a0 as a,D as h,Y as p}from"./framework-c2e81092.js";const d={},n=a('<h1 id="osi-7层网络模型" tabindex="-1"><a class="header-anchor" href="#osi-7层网络模型" aria-hidden="true">#</a> osi 7层网络模型</h1><h2 id="_1-osi的基本概念及原则" tabindex="-1"><a class="header-anchor" href="#_1-osi的基本概念及原则" aria-hidden="true">#</a> 1.OSI的基本概念及原则</h2><p>OSI是Open System Interconnect的缩写，意为开放式系统互联.<br> 其各个层次的划分遵循下列原则：</p><ul><li>同一层中的各网络节点都有相同的层次结构，具有同样的功能。</li><li>同一节点内相邻层之间通过接口进行通信。</li><li>七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。</li><li>不同节点的同等层按照协议实现对等层之间的通信。 <img src="http://pan.zghtools.run:5244/d/Onedrive/图片/osi七层模型2.webp?sign=olHtV--ftkniCekedmqVr_1V4YsJIhlP22QMLwhJZDQ=:0" alt="osi网络模型每层的协议" loading="lazy"></li></ul><h2 id="_2-层的概念" tabindex="-1"><a class="header-anchor" href="#_2-层的概念" aria-hidden="true">#</a> 2.层的概念</h2><p>层是对网络上的功能和行为进行分类和分组的一种方式。</p><p>在 OSI 模型中，层的组织结构从最具形态和最物理到不太有形，虚拟但更接近最终用户。</p><p>每一层都 抽象 低层的功能，直到最高层为止。最终用户是看不到所有其它层的所有细节和内部运作的。</p><p>分为:</p><ul><li>Please | 物理层（Physical Layer）</li><li>Do | 数据链路层（Data Link Layer）</li><li>Not | 网络层（Network Layer）</li><li>Tell （the）| 传输层（Transport Layer）</li><li>Secret | 会话层（Session Layer）</li><li>Password （to）| 表示层（Presentation Layer）</li><li>Anyone | 应用层（Application Layer）</li></ul><p>虽然某些技术（比如协议）在逻辑上比起其它层来说可能“属于”某一层，但并非所有的技术都完全契合 OSI 模型中的单个层。例如，以太网（Ethernet）、802.11（Wifi）和地址解析协议（ARP，Address Resolution Protocol）程序在不只一层上工作。</p>',11),s=a('<h2 id="_3-建立网络模型的目的" tabindex="-1"><a class="header-anchor" href="#_3-建立网络模型的目的" aria-hidden="true">#</a> 3.建立网络模型的目的</h2><p>解决异种网络互连时所遇到的兼容性问题，将服务、接口、协议概念分开。</p><ul><li><p>服务：某一层为上层提供一些什么功能</p></li><li><p>接口：上一层如何使用下层的服务</p></li><li><p>协议：如何实现本层的服务</p></li></ul><h2 id="第一层-物理层" tabindex="-1"><a class="header-anchor" href="#第一层-物理层" aria-hidden="true">#</a> 第一层：物理层</h2><p>物理媒体的基础上，规定物理设备标准：如网线的接口类型、光纤的接口类型、传输介质的传输速率等。1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0（一串0110……二进制位）</p><p>第一层的数据单元是比特（bit）。</p><p>比特是可传输数字信息的最小单元。比特是二进制的，要么为 0 要么为 1。字节（byte）由八个比特组成，用于表示单个字符，比如字母、数字或符号。</p><p>根据硬件设备支持的数据速率（传输速率，每秒或每毫秒的比特数量），比特被发送到硬件设备或从设备发出。这个过程是同步的，从而保持单位时间内发送和接收比特的数量相等（这被称为比特同步）。比特的传输方式由信号的传输方式决定。</p><p>节点可以发送比特、接收比特，或者收发兼顾。如果节点只能收或只能发，那么该节点采用的就是单工模式。如果节点既可以收又可以发，那么该节点采用的就是双工模式。如果一个节点可以同时进行收发操作，那么它就是全双工的，否则就是半双工的。</p><h2 id="第二层-数据链路层" tabindex="-1"><a class="header-anchor" href="#第二层-数据链路层" aria-hidden="true">#</a> 第二层：数据链路层</h2><p>它定义了数据的传输格式、可以在节点间流动的数据量大小、数据流动可以持续的时长，以及在流中检测到错误时应采取的措施。</p><p>第二层的数据单元是 帧（frame）。</p><p>每一帧都包括一个帧头、主体和一个帧尾：</p><ul><li>帧头：通常包括源节点和目的节点的 MAC 地址。</li><li>主体：由要传输的比特组成。</li><li>帧尾：包括错误检测信息。</li></ul><h2 id="第三层-网络层" tabindex="-1"><a class="header-anchor" href="#第三层-网络层" aria-hidden="true">#</a> 第三层：网络层</h2><p>提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。相当于传送邮件时需要地址一般重要。由于TCP/IP协议体系中的网路层功能由IP协议规定和实现，故又称IP层。</p><p>在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</p><p>第三层的数据单元是 数据包（data packet）。通常，每个数据包都包含一个帧 加上 一个 IP 地址信息的包装。换句话说，帧被第三层的地址信息封装了。</p><p>数据包中传输的数据有时也被称为 负载（payload）。每个包都拥有到达目的地所需的一切，但是它能不能成功抵达就是另外一回事儿了。</p><p>第三层上的传输是无连接的、尽力而为的——除了将流量发往它应该去的地方，它们不会做任何事。更多与数据传输有关的协议在第四层。</p><h2 id="第四层-传输层" tabindex="-1"><a class="header-anchor" href="#第四层-传输层" aria-hidden="true">#</a> 第四层: 传输层</h2><p>这一层也负责数据包的分段，或者说数据包如何被拆分成小片并发往整个网络。</p><p>不像上一层，第四层也理解整个消息，而不只是每个独立的数据包的内容。根据对整个消息的理解，第四层不再一次性发送所有数据包，从而管理网络拥塞。</p><p>第四层的数据单元有好几个不同的名字，对于 TCP 而言，数据单元是数据包。对于 UDP 而言，包被称为数据报（datagram）。</p><p>第四层中最有名的两个协议是传输控制协议（TCP，Transmission Control Protocol）和用户数据报协议（UDP，User Datagram Protocol）。</p><ul><li><p>TCP 是一个面向连接的协议，优先保证的是数据的质量而不是速度。</p></li><li><p>UDP 是一个无连接的协议，优先保证速度而不是数据的质量。UDP 不要求进行握手，这也正是它被称为无连接的原因。</p></li></ul><h2 id="第五层-会话层" tabindex="-1"><a class="header-anchor" href="#第五层-会话层" aria-hidden="true">#</a> 第五层: 会话层</h2><p>第五层是 会话层，负责建立、维持和终止会话。</p><h2 id="第六层-表示层" tabindex="-1"><a class="header-anchor" href="#第六层-表示层" aria-hidden="true">#</a> 第六层：表示层</h2><p>第六层是 表示层，负责数据的格式，比如字符编码与转换，以及数据加密。</p><h2 id="第七层-应用层" tabindex="-1"><a class="header-anchor" href="#第七层-应用层" aria-hidden="true">#</a> 第七层: 应用层</h2><p>这一层最终负责支持用户程序使用的服务。应用程序包括安装在操作系统中的软件程序，比如因特网浏览器（例如 Firefox）或文字处理程序（例如 Microsoft Word）。</p>',32);function c(_,u){const e=h("font");return r(),l("div",null,[n,t(e,{color:"red"},{default:o(()=>[p("OSI 只是一个模型，一个工具，并不是一组规则。")]),_:1}),s])}const P=i(d,[["render",c],["__file","osi七层模型.html.vue"]]);export{P as default};

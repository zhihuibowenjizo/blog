<template><div><h1 id="https加密原理" tabindex="-1"><a class="header-anchor" href="#https加密原理" aria-hidden="true">#</a> HTTPS加密原理</h1>
<h2 id="为什么要加密" tabindex="-1"><a class="header-anchor" href="#为什么要加密" aria-hidden="true">#</a> 为什么要加密</h2>
<blockquote>
<p>因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。</p>
</blockquote>
<h2 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h2>
<blockquote>
<p>简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。在服务器与客户端通信前，服务端会把密钥传给客户端，之后双方用密钥加密通信</p>
</blockquote>
<font color="red">只有密钥不被别人知道时，双方通信才算安全的，但是如果在传输过程中一旦被劫持(中间人攻击),密钥就会泄露</font><h2 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h2>
<blockquote>
<p>简单来说就是有两把密钥，一个公钥,一个私钥，用公钥加密的，只有私钥可以解，反之也是，公钥加密的，只有私钥能解。服务器先把公钥用明文的方式传给客户端，之后客户端向服务端传数据前，都先把数据用公钥加密后再传给服务端，服务端用私钥解密，查看内容，这样能解决单方面的通信安全，如果双方都用对称加密，似乎双向通信就都安全了，但是不行</p>
</blockquote>
<font color="red">
1. 性能问题，非对称加密算法非常耗时，而对称加密快很多  
2. 有漏洞(下面补充)
</font>
<h2 id="非对称加密-对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密-对称加密" aria-hidden="true">#</a> 非对称加密 + 对称加密</h2>
<blockquote>
<p>简单来说，就是客户端向服务器请求后，服务端先把服务器的公钥发给客户端,客户端随机生成一个用于对称通信的密钥X,用公钥A加密后传给服务端，服务端拿私钥解开，获得密钥X,然后双方就都拥有密钥X,之后的数据都用密钥X加密解密。  <mark>提升了性能，也提升了安全性</mark></p>
</blockquote>
<font color="red">
但是有一个严重的漏洞:
1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。
4. 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。
5. 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。
6. 服务器拿到后用私钥A’解密得到密钥X。
</font>  
还是会被中间人给攻击，<mark>其中最主要的原因是，客户端没法判别传过来的公钥到底是不是想要请求的服务器传过来的</mark>
<h2 id="如何证明客户端收到的公钥是想要请求的服务器传过来的" tabindex="-1"><a class="header-anchor" href="#如何证明客户端收到的公钥是想要请求的服务器传过来的" aria-hidden="true">#</a> 如何证明客户端收到的公钥是想要请求的服务器传过来的？</h2>
<p>需要一个可信的认证机构，它就是<mark>CA机构</mark>。CA机构会给我们要认证的服务器，颁发<mark>数字证书</mark></p>
<h2 id="数字证书" tabindex="-1"><a class="header-anchor" href="#数字证书" aria-hidden="true">#</a> 数字证书</h2>
<p>网站在使用<strong>HTTPS</strong>前，需要向CA机构申领一份<strong>数字证书</strong>，数字证书里含有证书持有者<strong>信息</strong>、<strong>公钥</strong>信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了<br>
数字证书还有强大的防伪技术，<strong>数字签名</strong></p>
<h2 id="数字签名" tabindex="-1"><a class="header-anchor" href="#数字签名" aria-hidden="true">#</a> 数字签名</h2>
<p>把证书原本的内容生成一份“签名”，对比证书内容和签名是否一致就能判别是否被篡改<br>
数字签名的制作过程</p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥</li>
<li>CA机构对证书明文数据进行hash</li>
<li>对hash后的值用私钥加密，就得到了数字签名</li>
</ol>
<font color="red">**明文和数字签名共同组成了数字证书**</font>  <p>浏览器验证过程：</p>
<ol>
<li>拿到证书,获得明文和签名</li>
<li>用CA机构的公钥对签名进行解密得到一个值</li>
<li>用证书中指明的hash算法，把明文T进行hash</li>
<li>把俩值相对比，如果相同，则证书可信！</li>
</ol>
<h2 id="中间人可能会篡改、掉包证书吗" tabindex="-1"><a class="header-anchor" href="#中间人可能会篡改、掉包证书吗" aria-hidden="true">#</a> 中间人可能会篡改、掉包证书吗？</h2>
<p>篡改证书这个问题，由于中间人没有CA的私钥，所以它造假了证书原文后无法生成签名，如果它用自己的私钥生成签名，那么客户端用CA公钥肯定无法解开，或者解开得到错误的散列值，因此中间人不可能篡改证书。证书掉包这个问题，就是中间人不自己制造假证书，而是找CA申请了一个合法的证书，但是这个证书肯定和客户端想要访问的服务端的，是不一样的，那么当中间人返回它的合法证书给客户端的时候，客户端可以验证证书是合法的，但是信息(域名等信息)是错的，即客户端知道这不是它要访问的网站，所以证书掉包也不可能。</p>
<h2 id="怎么证明ca机构的公钥是可信的" tabindex="-1"><a class="header-anchor" href="#怎么证明ca机构的公钥是可信的" aria-hidden="true">#</a> 怎么证明CA机构的公钥是可信的？？</h2>
<p>CA证书是干什么的？是来证明某公钥是不是可信的，那在给CA证书辨别真伪的时候也用到了CA证书的公钥，那些CA证书的公钥是否也需要数字证书的证明？
<mark>在操作系统、浏览器本身会预装一些他们信任的根证书，其中会有CA机构的根证书，这样就可以拿到可信的公钥了</mark><br>
实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p>
<p>另外，遇到过网站访问不了、提示需安装证书的情况，这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书**（风险自己承担XD）**。<strong>安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</strong></p>
<p>逻辑
安装CA机构的根证书，就是安装了我信任的CA机构，证书里的公钥可以来验证服务器发来的证书是否可信。
（CA证书验证用来验证请求服务器的公钥，但证书的验证本身也需要CA机构的公钥）</p>
</div></template>


